package services

import (
	"errors"
	"time"

	"github.com/jd-boyd/filesonthego/models"
	"github.com/rs/zerolog"
	"gorm.io/gorm"
)

// ShareService handles share link operations
type ShareService struct {
	db     *gorm.DB
	logger zerolog.Logger
}

// NewShareService creates a new share service
func NewShareService(db *gorm.DB, logger zerolog.Logger) *ShareService {
	return &ShareService{
		db:     db,
		logger: logger,
	}
}

// CreateShare creates a new share link
func (s *ShareService) CreateShare(userID, resourceID string, resourceType models.ResourceType, permissionType models.PermissionType, password string, expiresAt *time.Time) (*models.Share, error) {
	share := &models.Share{
		User:           userID,
		ResourceType:   resourceType,
		PermissionType: permissionType,
		ExpiresAt:      expiresAt,
	}

	// Set resource ID based on type
	if resourceType == models.ResourceTypeFile {
		share.File = resourceID
	} else {
		share.Directory = resourceID
	}

	// Set password if provided
	if password != "" {
		if err := share.SetPassword(password); err != nil {
			return nil, err
		}
	}

	// Create share in database (ShareToken will be auto-generated by BeforeCreate hook)
	if err := s.db.Create(share).Error; err != nil {
		return nil, err
	}

	s.logger.Info().
		Str("share_id", share.ID).
		Str("user_id", userID).
		Str("resource_type", string(resourceType)).
		Str("permission_type", string(permissionType)).
		Msg("Share created successfully")

	return share, nil
}

// GetShare retrieves a share by ID
func (s *ShareService) GetShare(shareID string) (*models.Share, error) {
	var share models.Share
	if err := s.db.First(&share, "id = ?", shareID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("share not found")
		}
		return nil, err
	}
	return &share, nil
}

// GetShareByToken retrieves a share by token
func (s *ShareService) GetShareByToken(shareToken string) (*models.Share, error) {
	var share models.Share
	if err := s.db.Where("share_token = ?", shareToken).First(&share).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("share not found")
		}
		return nil, err
	}
	return &share, nil
}

// ListUserShares lists all shares created by a user
func (s *ShareService) ListUserShares(userID string) ([]*models.Share, error) {
	var shares []*models.Share
	if err := s.db.Where("user = ?", userID).Order("created_at DESC").Find(&shares).Error; err != nil {
		return nil, err
	}
	return shares, nil
}

// RevokeShare deletes a share
func (s *ShareService) RevokeShare(shareID string) error {
	result := s.db.Delete(&models.Share{}, "id = ?", shareID)
	if result.Error != nil {
		return result.Error
	}
	if result.RowsAffected == 0 {
		return errors.New("share not found")
	}

	s.logger.Info().
		Str("share_id", shareID).
		Msg("Share revoked successfully")

	return nil
}

// UpdateShare updates share properties
func (s *ShareService) UpdateShare(shareID string, updates map[string]interface{}) (*models.Share, error) {
	share, err := s.GetShare(shareID)
	if err != nil {
		return nil, err
	}

	// Handle password update separately
	if password, ok := updates["password"].(string); ok {
		if err := share.SetPassword(password); err != nil {
			return nil, err
		}
		delete(updates, "password")
		updates["password_hash"] = share.PasswordHash
	}

	if err := s.db.Model(share).Updates(updates).Error; err != nil {
		return nil, err
	}

	// Reload share
	return s.GetShare(shareID)
}

// IncrementAccessCount increments the access count for a share
func (s *ShareService) IncrementAccessCount(shareID string) error {
	var share models.Share
	if err := s.db.First(&share, "id = ?", shareID).Error; err != nil {
		return err
	}

	return share.IncrementAccessCount(s.db)
}

// LogShareAccess logs an access to a share
func (s *ShareService) LogShareAccess(shareID, ipAddress, userAgent, action, fileName string) error {
	log := &models.ShareAccessLog{
		Share:     shareID,
		IPAddress: ipAddress,
		UserAgent: userAgent,
		Action:    action,
		FileName:  fileName,
	}

	if err := s.db.Create(log).Error; err != nil {
		s.logger.Error().
			Err(err).
			Str("share_id", shareID).
			Str("action", action).
			Msg("Failed to log share access")
		return err
	}

	return nil
}

// GetShareAccessLogs retrieves access logs for a share
func (s *ShareService) GetShareAccessLogs(shareID string, limit int) ([]*models.ShareAccessLog, error) {
	var logs []*models.ShareAccessLog
	query := s.db.Where("share = ?", shareID).Order("created_at DESC")

	if limit > 0 {
		query = query.Limit(limit)
	}

	if err := query.Find(&logs).Error; err != nil {
		return nil, err
	}

	return logs, nil
}

// CleanupExpiredShares removes expired shares (should be run periodically)
func (s *ShareService) CleanupExpiredShares() (int64, error) {
	now := time.Now()
	result := s.db.Where("expires_at IS NOT NULL AND expires_at < ?", now).Delete(&models.Share{})

	if result.Error != nil {
		return 0, result.Error
	}

	if result.RowsAffected > 0 {
		s.logger.Info().
			Int64("count", result.RowsAffected).
			Msg("Cleaned up expired shares")
	}

	return result.RowsAffected, nil
}
